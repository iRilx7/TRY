
import sb from './supabaseClient.js'; import { $, toast } from './utils.js';
import { listNovels, saveNovel, deleteNovel, getNovelById, chaptersForNovel, nextChapterNumber, createChapter, updateChapter, deleteChapter } from './api.js';
async function isAdmin(){ const u=(await sb.auth.getUser()).data.user; if(!u) return false; return !!(await sb.from('admins').select('user_id').eq('user_id',u.id).maybeSingle()).data; }
async function guard(){ if(!(await isAdmin())){ document.getElementById('guard').textContent='You are not an admin or not logged in.'; return; } document.getElementById('guard').classList.add('hidden'); document.getElementById('cms').classList.remove('hidden'); init(); }
let currentId=null;
async function refreshList(){ const q=document.getElementById('nv_q').value.trim(); const list=await listNovels(q); const ul=document.getElementById('nv_list'); ul.innerHTML=''; list.forEach(n=>{ const li=document.createElement('li'); li.innerHTML=`<a href="#" data-id="${n.id}">${n.title}</a>`; ul.append(li); }); ul.onclick=async e=>{ const a=e.target.closest('a[data-id]'); if(!a) return; e.preventDefault(); loadNovel(Number(a.dataset.id)); }; }
async function loadNovel(id){ const n=await getNovelById(id); currentId=id; document.getElementById('n_id').value=id; document.getElementById('n_title').value=n.title||''; document.getElementById('n_author').value=n.author||''; document.getElementById('n_desc').value=n.description||''; document.getElementById('n_cover_url').value=n.cover_url||''; await loadChList(); }
async function loadChList(){ const tb=document.getElementById('chapTable'); tb.innerHTML=''; if(!currentId) return; const list=await chaptersForNovel(currentId); list.forEach(c=>{ const tr=document.createElement('tr'); tr.innerHTML=`<td>${c.chapter_number}</td><td>${c.title}</td><td>${new Date(c.created_at).toLocaleString()}</td><td><button data-edit="${c.chapter_number}">Edit</button></td>`; tb.append(tr); }); tb.onclick=e=>{ const n=e.target.getAttribute('data-edit'); if(!n) return; const row=list.find(x=>x.chapter_number==n); document.getElementById('c_num').value=row.chapter_number; document.getElementById('c_title').value=row.title; sb.from('chapters').select('content').eq('id',row.id).single().then(({data})=>document.getElementById('c_content').value=data?.content||''); }; }
document.getElementById('nv_search').onclick=refreshList;
document.getElementById('saveNovel').onclick=async()=>{ const data=await saveNovel({ id: document.getElementById('n_id').value?Number(document.getElementById('n_id').value):null, title:n_title.value, author:n_author.value, description:n_desc.value, cover_url:n_cover_url.value }); currentId=data.id; document.getElementById('n_id').value=data.id; toast('Saved'); refreshList(); };
document.getElementById('deleteNovel').onclick=async()=>{ if(!currentId) return; if(!confirm('Delete novel?')) return; await deleteNovel(currentId); toast('Deleted'); currentId=null; refreshList(); };
document.getElementById('suggestNum').onclick=async()=>{ if(!currentId) return alert('Save/select novel first'); document.getElementById('c_num').value=await nextChapterNumber(currentId); };
document.getElementById('createChapter').onclick=async()=>{ await createChapter(currentId, Number(c_num.value), c_title.value, c_content.value); toast('Chapter created'); loadChList(); };
document.getElementById('updateChapter').onclick=async()=>{ await updateChapter(currentId, Number(c_num.value), c_title.value, c_content.value); toast('Chapter updated'); };
document.getElementById('deleteChapter').onclick=async()=>{ await deleteChapter(currentId, Number(c_num.value)); toast('Chapter deleted'); loadChList(); };
document.getElementById('uploadCover').onclick=async()=>{ const f=document.getElementById('cover').files[0]; if(!f) return alert('pick image'); const path = `${{currentId||'temp'}}/${{Date.now()}}_${{f.name}}`; const {{ error }} = await sb.storage.from('covers').upload(path, f, {{upsert:true}}); if(error) alert(error.message); else document.getElementById('n_cover_url').value=sb.storage.from('covers').getPublicUrl(path).data.publicUrl; };
async function init(){ await refreshList(); }
guard();
